<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Premiere XML → Timeline CSV (Browser)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; color:#111; }
    h1 { margin:0 0 8px 0; font-size:20px; }
    .controls { display:flex; gap:12px; flex-wrap:wrap; margin:10px 0 18px 0; align-items:center; }
    label { font-size:13px; color:#333; }
    input[type="file"] { padding:6px; }
    select, input[type="number"] { padding:6px; border-radius:6px; border:1px solid #ddd; }
    button { padding:8px 12px; border-radius:8px; border:0; background:#0b76ff; color:white; cursor:pointer; }
    button[disabled]{ background:#bbb; cursor:default; }
    table { border-collapse:collapse; width:100%; margin-top:12px; }
    th,td { border:1px solid #eee; padding:6px 8px; text-align:left; font-size:13px; }
    th { background:#fafafa; }
    .note { font-size:13px; color:#555; margin-top:8px; }
    .small { font-size:12px; color:#666; }
    #log { white-space:pre-wrap; background:#f8f9fb; padding:8px; border-radius:6px; border:1px solid #eee; margin-top:10px; }
  </style>
</head>
<body>
  <h1>Premiere XML → Timeline CSV (runs in your browser)</h1>
  <div class="note">Upload a Premiere/Final Cut XML exported from Premiere Pro 2024 (keeps file strictly local in your browser).</div>

  <div class="controls">
    <label>XML file
      <input id="xmlFile" type="file" accept=".xml,.xmeml" />
    </label>

    <label>Sequence
      <select id="seqSelect" disabled>
        <option>— load a file —</option>
      </select>
    </label>

    <label>FPS
      <input id="fpsInput" type="number" min="1" value="25" style="width:80px" />
    </label>

    <label>Round threshold (frames)
      <input id="thresholdInput" type="number" min="0" value="13" style="width:80px" />
    </label>

    <button id="parseBtn" disabled>Parse & Preview</button>
    <button id="downloadBtn" disabled>Download CSV</button>
  </div>

  <div id="results"></div>
  <div id="log" style="display:none"></div>

<script>
/*
  Browser-based Premiere XML -> CSV
  - Supports nested sequences (common reference patterns)
  - Separates video/audio tracks and track index (V1, V2, A1, ...)
  - Timeline in/out only (hh:mm:ss), with rounding rule:
      remainderFrames >= threshold -> round up to next second
      remainderFrames <= threshold-1 -> round down
  - Works offline in the browser (no upload to any server)
*/

const xmlInput = document.getElementById('xmlFile');
const seqSelect = document.getElementById('seqSelect');
const fpsInput = document.getElementById('fpsInput');
const thresholdInput = document.getElementById('thresholdInput');
const parseBtn = document.getElementById('parseBtn');
const downloadBtn = document.getElementById('downloadBtn');
const resultsDiv = document.getElementById('results');
const logDiv = document.getElementById('log');

let xmlDoc = null;
let sequences = []; // array of {name, id, element}
let seqByName = {};
let seqById = {};

function showLog(msg) {
  logDiv.style.display = 'block';
  logDiv.textContent = msg;
}

// Utility: safe text getter
function getText(node, tag) {
  if (!node) return null;
  const el = node.getElementsByTagName(tag)[0];
  return el ? (el.textContent || '').trim() : null;
}

// Detect fps from xml: look for any <rate><timebase>
function detectFps(doc, fallback=25) {
  const tb = doc.querySelector('rate > timebase');
  if (tb && tb.textContent) {
    const val = parseInt(tb.textContent.trim(), 10);
    if (!isNaN(val) && val > 0) return val;
  }
  return fallback;
}

// Parse uploaded XML string into DOM
function parseXmlString(xmlText) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(xmlText, 'application/xml');
  const err = doc.getElementsByTagName('parsererror');
  if (err && err.length) throw new Error('XML parse error: ' + err[0].textContent.trim().slice(0,200));
  return doc;
}

// Build maps of sequences
function buildSequenceMaps(doc) {
  sequences = [];
  seqByName = {};
  seqById = {};
  const seqEls = Array.from(doc.getElementsByTagName('sequence'));
  seqEls.forEach((seqEl, ix) => {
    let name = getText(seqEl, 'name') || `Sequence ${ix+1}`;
    // try attribute id first
    let id = seqEl.getAttribute('id') || getText(seqEl, 'id') || null;
    // normalize
    name = name.trim();
    sequences.push({ name, id, el: seqEl });
    seqByName[name] = seqEl;
    if (id) seqById[id] = seqEl;
  });
}

// When a clip references a nested sequence it can do so in multiple ways.
// This function tries a few common spots and returns a reference string (id or name) if found.
function findSequenceRefInClip(clipEl) {
  // 1) <sequence> as a child (may contain a <name> or text)
  const seqChild = clipEl.getElementsByTagName('sequence')[0];
  if (seqChild) {
    const innerName = getText(seqChild, 'name');
    if (innerName) return { type:'name', value: innerName.trim() };
    const raw = (seqChild.textContent || '').trim();
    if (raw) return { type:'name', value: raw };
  }
  // 2) <link><linkclipref>ID</linkclipref></link>
  const linkclipref = clipEl.querySelector('link > linkclipref') || clipEl.getElementsByTagName('linkclipref')[0];
  if (linkclipref && linkclipref.textContent) {
    return { type:'id', value: linkclipref.textContent.trim() };
  }
  // 3) masterclipid or masterclipname (some exports)
  const mcid = getText(clipEl, 'masterclipid');
  if (mcid) return { type:'id', value: mcid };
  const mcname = getText(clipEl, 'masterclipname');
  if (mcname) return { type:'name', value: mcname };
  // nothing recognized
  return null;
}

// Try resolve a reference (id or name) to a sequence element
function resolveSequenceRef(ref) {
  if (!ref) return null;
  if (ref.type === 'id') {
    if (seqById[ref.value]) return seqById[ref.value];
    // fallback: try find by id substring
    for (const k in seqById) if (k && k.includes(ref.value)) return seqById[k];
  } else if (ref.type === 'name') {
    if (seqByName[ref.value]) return seqByName[ref.value];
    // fallback: case-insensitive or partial
    const valLower = ref.value.toLowerCase();
    for (const s of sequences) {
      if (s.name.toLowerCase() === valLower) return s.el;
    }
    for (const s of sequences) {
      if (s.name.toLowerCase().includes(valLower) || valLower.includes(s.name.toLowerCase())) return s.el;
    }
  }
  return null;
}

// Convert frames -> hh:mm:ss using fps and threshold (threshold: frames at which we round up)
function framesToTimeRounded(frames, fps, threshold) {
  const fullSeconds = Math.floor(frames / fps);
  const remainder = frames % fps;
  const seconds = (remainder >= threshold) ? (fullSeconds + 1) : fullSeconds;
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

// The recursive extractor. parentOffsetFrames is where the sequence is placed on its parent timeline.
function extractClipsFromSequence(seqEl, parentOffsetFrames, fps, threshold) {
  const results = [];

  // Helper to iterate direct child <track> elements in a container (avoid finding tracks from deeper nesting)
  function directTracks(container) {
    if (!container) return [];
    const out = [];
    for (const ch of Array.from(container.children)) {
      if (ch.tagName && ch.tagName.toLowerCase() === 'track') out.push(ch);
    }
    return out;
  }

  // VIDEO
  const mediaEl = seqEl.getElementsByTagName('media')[0];
  if (mediaEl) {
    const videoContainer = mediaEl.getElementsByTagName('video')[0];
    if (videoContainer) {
      const tracks = directTracks(videoContainer);
      tracks.forEach((trackEl, idx) => {
        const vIdx = idx + 1;
        const clipItems = Array.from(trackEl.getElementsByTagName('clipitem'));
        clipItems.forEach(clip => {
          const name = getText(clip, 'name') || '';
          const startRaw = parseInt(getText(clip, 'start') || '0', 10);
          const endRaw = parseInt(getText(clip, 'end') || '0', 10);
          const start = (isNaN(startRaw) ? 0 : startRaw) + (parentOffsetFrames || 0);
          const end = (isNaN(endRaw) ? 0 : endRaw) + (parentOffsetFrames || 0);

          const ref = findSequenceRefInClip(clip);
          const nestedSeqEl = resolveSequenceRef(ref);
          if (nestedSeqEl) {
            // Recurse into nested sequence; preserve parent's track type/index for all nested items
            const nested = extractClipsFromSequence(nestedSeqEl, start, fps, threshold);
            nested.forEach(nc => {
              nc.track_type = 'video';
              nc.track_index = `V${vIdx}`;
            });
            results.push(...nested);
          } else {
            results.push({
              name: name,
              timeline_in: framesToTimeRounded(start, fps, threshold),
              timeline_out: framesToTimeRounded(end, fps, threshold),
              track_type: 'video',
              track_index: `V${vIdx}`,
              _start_seconds: Math.floor(start / fps) + ((start % fps >= threshold) ? 1 : 0)
            });
          }
        });
      });
    }

    // AUDIO
    const audioContainer = mediaEl.getElementsByTagName('audio')[0];
    if (audioContainer) {
      const aTracks = directTracks(audioContainer);
      aTracks.forEach((trackEl, idx) => {
        const aIdx = idx + 1;
        const clipItems = Array.from(trackEl.getElementsByTagName('clipitem'));
        clipItems.forEach(clip => {
          const name = getText(clip, 'name') || '';
          const startRaw = parseInt(getText(clip, 'start') || '0', 10);
          const endRaw = parseInt(getText(clip, 'end') || '0', 10);
          const start = (isNaN(startRaw) ? 0 : startRaw) + (parentOffsetFrames || 0);
          const end = (isNaN(endRaw) ? 0 : endRaw) + (parentOffsetFrames || 0);

          const ref = findSequenceRefInClip(clip);
          const nestedSeqEl = resolveSequenceRef(ref);
          if (nestedSeqEl) {
            const nested = extractClipsFromSequence(nestedSeqEl, start, fps, threshold);
            nested.forEach(nc => {
              nc.track_type = 'audio';
              nc.track_index = `A${aIdx}`;
            });
            results.push(...nested);
          } else {
            results.push({
              name: name,
              timeline_in: framesToTimeRounded(start, fps, threshold),
              timeline_out: framesToTimeRounded(end, fps, threshold),
              track_type: 'audio',
              track_index: `A${aIdx}`,
              _start_seconds: Math.floor(start / fps) + ((start % fps >= threshold) ? 1 : 0)
            });
          }
        });
      });
    }
  }

  return results;
}

// Create CSV text
function clipsToCSV(clips) {
  const hdr = ['name','timeline_in','timeline_out','track_type','track_index'];
  const escape = s => {
    if (s === null || s === undefined) return '';
    const str = String(s);
    // double quotes inside string should be doubled
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
  };
  const rows = [hdr.join(',')];
  clips.forEach(r => {
    rows.push([
      escape(r.name),
      escape(r.timeline_in),
      escape(r.timeline_out),
      escape(r.track_type),
      escape(r.track_index)
    ].join(','));
  });
  return rows.join('\n');
}

// Render HTML table preview
function renderTable(clips) {
  if (!clips || !clips.length) {
    resultsDiv.innerHTML = `<div class="note small">No clips found in that sequence (or after rounding).</div>`;
    return;
  }
  let html = '<table><thead><tr><th>#</th><th>Name</th><th>Timeline In</th><th>Timeline Out</th><th>Track</th><th>Type</th></tr></thead><tbody>';
  clips.forEach((c, i) => {
    html += `<tr><td>${i+1}</td><td>${escapeHtml(c.name)}</td><td>${c.timeline_in}</td><td>${c.timeline_out}</td><td>${c.track_index}</td><td>${c.track_type}</td></tr>`;
  });
  html += '</tbody></table>';
  resultsDiv.innerHTML = html;
}

function escapeHtml(s) {
  if (!s) return '';
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// EVENT: file selected
xmlInput.addEventListener('change', async (ev) => {
  const f = ev.target.files[0];
  if (!f) return;
  try {
    const txt = await f.text();
    xmlDoc = parseXmlString(txt);
    buildSequenceMaps(xmlDoc);
    // populate select
    seqSelect.innerHTML = '';
    if (sequences.length === 0) {
      seqSelect.disabled = true;
      parseBtn.disabled = true;
      showLog('No <sequence> elements found in XML.');
      return;
    }
    sequences.forEach((s, i) => {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${s.name}${s.id ? ' ('+s.id+')' : ''}`;
      seqSelect.appendChild(opt);
    });
    seqSelect.disabled = false;
    parseBtn.disabled = false;
    // detect fps
    const detected = detectFps(xmlDoc, parseInt(fpsInput.value||25,10));
    fpsInput.value = detected;
    logDiv.style.display='none';
    resultsDiv.innerHTML = `<div class="small">Loaded file: ${f.name} — found ${sequences.length} sequence(s). Detected FPS: ${detected}</div>`;
  } catch (err) {
    showLog('Error parsing XML: ' + err.message);
  }
});

// EVENT: parse & preview selected sequence
parseBtn.addEventListener('click', () => {
  if (!xmlDoc || !sequences.length) return;
  const chosenIx = parseInt(seqSelect.value, 10);
  if (Number.isNaN(chosenIx)) return;
  const seq = sequences[chosenIx];
  const fps = Math.max(1, parseInt(fpsInput.value || '25', 10));
  const threshold = Math.max(0, parseInt(thresholdInput.value || '13', 10));
  resultsDiv.innerHTML = `<div class="small">Parsing sequence: <strong>${seq.name}</strong> (FPS=${fps}, threshold=${threshold}) ...</div>`;

  try {
    let clips = extractClipsFromSequence(seq.el, 0, fps, threshold);
    // Sort by numeric start time (_start_seconds)
    clips.sort((a,b) => (a._start_seconds || 0) - (b._start_seconds || 0));
    // Remove internal _start_seconds before render/export
    clips = clips.map(c => {
      const copy = Object.assign({}, c);
      delete copy._start_seconds;
      return copy;
    });
    // render and enable download
    renderTable(clips);
    downloadBtn.disabled = (clips.length === 0);
    // store CSV content on the element for quick download
    const csv = clipsToCSV(clips);
    downloadBtn.dataset.csv = csv;
  } catch (err) {
    showLog('Error extracting clips: ' + err.message);
  }
});

// EVENT: download CSV
downloadBtn.addEventListener('click', () => {
  const csv = downloadBtn.dataset.csv;
  if (!csv) return;
  const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'premiere_timeline.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

</script>
</body>
</html>
